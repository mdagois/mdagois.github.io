<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Coding Adventure</title>
    <link rel="stylesheet" href="../bootstrap.min.css">
    <style>
      .asmlisting {
        border: 2px dashed white;
        padding: 20px;
        margin: 0;
        width: fit-content
      }
    </style>
  </head>
  <body>
    <nav class="navbar navbar-expand-lg bg-primary" data-bs-theme="dark">
      <div class="container-fluid">
      <div class="navbar-brand">Coding Adventures</div>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarColor01" aria-controls="navbarColor01" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarColor01">
        <ul class="navbar-nav me-auto">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">Home</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../portfolio.html">Portfolio</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../about.html">About</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../contact.html">Contact</a>
        </li>
        </ul>
      </div>
      </div>
    </nav>

    <div class="container">
      <br/>
      <p>
        <img src="../images/gameboy.png" alt="gameboy" class="rounded mx-auto d-block">
      </p>

      <h3>Parallax Scrolling on the Game Boy</h3>
        <p>
          This article is an in-depth guide to implementing parallax scrolling on the Game Boy.
          It presents two techniques that you can use to add parallax scrolling to your Game Boy games.
        </p>
        <p>
          We'll start by reviewing what parallax scrolling is, and what the challenges are to implement it on the Game Boy.
        </p>
        <p>
          Then, we'll go over the two parallax techniques: the <i>hblank</i> method and the <i>tile</i> method.
          We'll show how to implement those techniques and explain their benefits and drawbacks.
          We'll use assembly code samples to show all the implementation details.
          However, the concepts presented in this article should also be relevant to games programmed in C,
          and the techniques might be applicable to other consoles as well, such as the NES or Master System.
        </p>
        <p>
          By the end of the article, you'll have a strong grasp of what it takes to implement parallax scrolling on the Game Boy.
          You'll also be able to choose the best parallax techniques for your game.
        </p>

        <h4>Target Audience</h4>
          <p>
            Anyone interested in game development can grasp the concepts presented in this article.
            However, you should be familiar with programming the Game Boy in assembly in order to follow along with the code samples.
            To get a strong introduction to Game Boy programming in assembly, I recommend you to check my book,
            <a href="https://mdagois.gumroad.com/l/CODQn" target="_blank">Game Boy Coding Adventure</a>.
            It is a complete coverage of all the aspects the Game Boy, using a beginner-friendly approach for those new to assembly.
          </p>

        <h4>What is Parallax Scrolling</h4>
          <p>
            Parallax scrolling is a graphics technique used to create the illusion of depth with 2D graphics.
            The effect of parallax scrolling is shown in Figure 1.
            <figure>
              <img src="../images/parallax/parallax_scrolling.gif" alt="Parallax scrolling">
              <figcaption>Figure 1: Parallax scrolling</figcaption>
            </figure>
            Graphics elements are placed on distinct layers that moves at different paces.
            The further away a layer is meant to be from the observer, the slower it moves.
          </p>
          <p>
            What makes parallax scrolling challenging on the Game Boy is that the console only supports one single background layer.
            So, we have to leverage the hardware capabilities to mimic the effect of having several background layers.
          </p>

      <h4>The hblank Method</h4>
        <p>
          The first technique we'll study is the <i>hblank</i> method.
          In my <a href="https://mdagois.gumroad.com/l/CODQn" target="_blank">book</a>, I go over two versions of hblank parallax:
          one <i>naive</i> implementation and one <i>optimized</i> implementation.
          The naive implementation uses the hblank interrupt exclusively to set the scrolling value.
          The problem with this implementation is that we get interrupts on each line, even though we are only interested in two lines (87 and 111).
          This ends up wasting a lot of cycles that could be better used for actual game logic.
          The optimized implementation fixed the performance issue of the naive implementation by using the line compare interrupt.
          This was reducing the number of interrupts from 144 to 4 during the LCD refresh.
          The only issue of the optimized implementation is that it would trigger the <code>rSTAT</code> bug.
          The <code>rSTAT</code> bug is a nasty hardware issue that occurs on the original Game Boy.
          The bug causes spurious LCD interrupts to trigger when the <code>rSTAT</code> register is written to.
          In this article, we'll use a modified version of the optimized implementation.
          It has the benefit of avoiding the <code>rSTAT</code> bug by writing to the <code>rSTAT</code> register exclusively from inside the interrupt function.
          This makes it the best implementation of the three.
        </p>

        <h5>Checking the Sample</h5>
          <p>
            Figure 2 is a video of the hblank sample.
            It consists in an astronaut walking on a planet.
          </p>
          <figure>
            <video autoplay loop muted preload="auto">
              <source src="../video/parallax/hblank.mp4" type="video/mp4">
              Your browser does not support the video tag.
            </video>
            <figcaption>Figure 2: Parallax scrolling using the hblank method</figcaption>
          </figure>
          <p>
            The planets and stars appear to be at a great distance, while the rocks appear farther away than the ground.
            To achieve this parallax effect, the idea is to split the screen horizontally into three different layers.
            The top layer contains the planets and stars.
            The middle layer contains the rocks.
            The bottom layer contains the ground on which the astronauts walks.
            The layers are shown in Figure 3, with red lines separating them.
          </p>
          <figure>
            <img src="../images/parallax/layers.png" alt="Parallax layers">
            <figcaption>Figure 3: Parallax layers</figcaption>
          </figure>
          <p>
            The sky layer extends from lines 0 to 87.
            The rock spans lines 88 to 111.
            The ground covers the remaining lines, from 112 to 143.
            Each layer is scrolled at a different pace when the astronaut walks around in order to create the parallax effect.
          </p>

        <h5>Understanding the Algorithm</h5>
          <p>
            On the Game Boy, the horizontal scrolling of the background is controlled by the <code>rSCX</code> register.
            We'll use the hblank interrupt to change the value of the <code>rSCX</code> register on lines 87 and 111.
          </p>
          <p>
            First, we'll compute the horizontal scrolling value for all three layers.
            Those scrolling values will be updated based on the movement of the astronaut.
            We'll use different variables to compute the scrolling values to avoid any interference with the current LCD refresh.
            Then, during the vblank, we'll set the <code>rSCX</code> register to the value of the sky scrolling.
            We'll also copy the values for the scrolling of the rocks and ground into variables used in the interrupts.
            Finally, when the next LCD refresh starts, the scrolling for the sky will be correct already.
            As the interrupts trigger on lines 87 and 111, the <code>rSCX</code> register gets updated with the appropriate scrolling value.
            This creates the parallax effect.
            We'll see that there are a few more details when we check the actual assembly code.
          </p>

        <h5>Diving into the Sample Code</h5>
        <p>
          In this section, we'll dive into the sample code.
          We'll see the most important details of the implementation.
          You can get the fully commented code at XXX.
          There is also a prebuilt ROM available at XXX.
        </p>
        <p>
          The sample declares several constants, as shown in Listing 1.
        </p>
        <figure>
          <pre class="asmlisting">
def LINE_ROCKS                      equ 87
def LINE_GROUND                     equ 111

def SKY_SPEED_X                     equ $0040
def ROCKS_SPEED_X                   equ $0080
def GROUND_SPEED_X                  equ $0100</pre>
        <figcaption>Listing 1: Constants declaration</figcaption>
        <p>
          First, we have two constants, <code>LINE_ROCKS</code> and <code>LINE_GROUND</code>, that define the lines on which we'll change the scrolling values for the rocks and ground respectively.
          Then, we define the speeds at which the sky, rocks, and ground moves when the astronaut walks around.
          We use 16-bit literals to have a more granular control over the speed of each layer.
          Those literals are fixed-point numbers.
          The most significant byte of the literal represents the integral part, while the least significant byte represents the fractional part.
          For example, <code>GROUND_SPEED_X</code> represents the number <code>1.0</code>, and <code>ROCKS_SPEED_X</code> represents <code>0.5</code>.
        </p>
        <p>
          The sample uses several variables to store the layers' scrolling values.
          In the sample, all the variables are stored in WRAM, but you could also have them in HRAM and benefits from the <code>ldh</code> instruction.
          The variables are shown in Listing 2.
        </p>
        <figure>
          <pre class="asmlisting">
rsset _RAM
    ...

    def WRAM_SKY_POSITION_X             rb 2
    def WRAM_ROCKS_POSITION_X           rb 2
    def WRAM_GROUND_POSITION_X          rb 2

    def WRAM_ROCKS_SCROLLING_X          rb 1
    def WRAM_GROUND_SCROLLING_X         rb 1</pre>
        <figcaption>Listing 2: Variables declaration</figcaption>
        <p>
          First, we have the three fixed-point numbers to hold the positions of each layer.
          We'll see how these are updated soon.
          Then, we have two <i>buffer</i> variables.
          These hold the values meant to be copied to the <code>rSCX</code> register during the hblank interrupts.
          Their values is basically equal to the high bytes of the corresponding positions.
          For example, <code>WRAM_ROCKS_SCROLLING_X</code> will hold the high byte of <code>WRAM_ROCKS_POSITION_X</code>.
          The reason we don't use the positions' high byte directly is that we need to keep the scrolling values stable during the LCD refresh, at least until line 112.
          Because the positions might get updated in the sample main loop before the interrupts are triggered, we need to copy their value to those buffer variables that are guaranteed to be stable through the LCD refresh.
          Note that we don't have a buffer variables for the sky.
          We'll see why that is when we check the vblank code.
          All the WRAM variables will be cleared to zero at initialization time.
        </p>
        <p>
          At initialization time, the sample sets the interrupts as shown in Listing 3.
        </p>
        <figure>
          <pre class="asmlisting">
ld a, LINE_ROCKS
ldh [rLYC], a

ld a, STATF_LYC
ldh [rSTAT], a

ld a, IEF_VBLANK | IEF_LCDC
ld [rIE], a
ei</pre>
        <figcaption>Listing 3: Sample initialization</figcaption>
        <p>
          First, we set the target line, in the <code>rLYC</code> register, for the line compare interrupt to the value of the rocks line (<code>LINE_ROCKS</code>).
          The target line will change through the frame, but at the start of every frame, it will always set back to <code>LINE_ROCKS</code>, because that's the first line on which we need to change the value of the <code>rSCX</code> register every frame.
          Then, we raise the flag for the line compare interrupt in the <code>rSTAT</code> register.
          This is an essential step to enable the line compare interrupt, which is one type of LCD interrupt.
          Note that the hblank flag isn't raised yet in the <code>rSTAT</code> register.
          We don't want hblank interrupts to trigger on each line as it would waste cycles.
          We'll raise the flag only when necessary.
          Finally, we enable both the vblank and LCD interrupts.
          The vblank interrupt is essential for frame pacing, and we'll also use it to prepare for the line and hblank interrupts.
          The LCD interrupt is an umbrella interrupt that encompass the the line compare and hblank interrupts, which we rely on to implement the parallax effect.
        </p>
        <p>
          During the LCD refresh, we compute the position of all the layers for the next frame, as shown in Listing 4.
        </p>
        <figure>
          <pre class="asmlisting">
.astronaut_move
    ; Update all the scrolling values based on the astronaut direction
    ld a, [ASTRONAUT_MOVE_DIRECTION]
    cp a, DIRECTION_LEFT
    jr nz, .direction_left
        u16_sub WRAM_SKY_POSITION_X, SKY_SPEED_X
        u16_sub WRAM_ROCKS_POSITION_X, ROCKS_SPEED_X
        u16_sub WRAM_GROUND_POSITION_X, GROUND_SPEED_X
        jr .astronaut_move_done
    .direction_left
    cp a, DIRECTION_RIGHT
    jr nz, .direction_right
        u16_add WRAM_SKY_POSITION_X, SKY_SPEED_X
        u16_add WRAM_ROCKS_POSITION_X, ROCKS_SPEED_X
        u16_add WRAM_GROUND_POSITION_X, GROUND_SPEED_X
    .direction_right
.astronaut_move_done</pre>
        <figcaption>Listing 4: Layer positions update</figcaption>
        <p>
          We add or subtract the speeds to the layer positions based on the direction the astronaut is walking to.
          The <code>u16_add</code> and <code>u16_sub</code> macros handle the fixed-point arithmetic.
          You can check their code in the GitHub repository.
        </p>
        <p>
          The updated positions are used during the vblank to prepare for the interrupts.
          The relevant vblank code is shown in Listing 5.
        </p>
        <figure>
          <pre class="asmlisting">
ld a, [WRAM_SKY_POSITION_X + 1]
ld [rSCX], a

ld a, [WRAM_ROCKS_POSITION_X + 1]
ld [WRAM_ROCKS_SCROLLING_X], a
ld a, [WRAM_GROUND_POSITION_X + 1]
ld [WRAM_GROUND_SCROLLING_X], a</pre>
        <figcaption>Listing 5: Scrolling update during vblank</figcaption>
        <p>
          First, we update the <code>rSCX</code> register so that it has the sky scrolling value when the LCD refresh starts.
          Then, as mentioned earlier, we use buffer variables, <code>WRAM_ROCKS_SCROLLING_X</code> and <code>WRAM_GROUND_SCROLLING_X</code>, to keep the scrolling values for the rocks and ground layers stable during the whole LCD refresh, and in particular, for the corresponding hblank interrupts.
        </p>
        <p>
          The final piece of the algorithm is the LCD interrupt function, which handles both the line compare interrupts and the hblank interrupts.
          The complete function is shown in Listing 6.
        </p>
        <figure>
          <pre class="asmlisting">
LcdInterrupt:
    ldh a, [rSTAT]
    bit STATB_MODE00, a

    ld a, STATF_MODE00
    ldh [rSTAT], a

    ret z

    ld a, [rLY]
    cp a, LINE_ROCKS
    jr nz, .middle_section
        ld a, [WRAM_ROCKS_SCROLLING_X]
        ldh [rSCX], a

        ld a, LINE_GROUND
        ldh [rLYC], a

        ld a, STATF_LYC
        ldh [rSTAT], a

        ret
    .middle_section

    ld a, [WRAM_GROUND_SCROLLING_X]
    ldh [rSCX], a

    ld a, LINE_ROCKS
    ldh [rLYC], a

    ld a, STATF_LYC
    ldh [rSTAT], a

    ret</pre>
        <figcaption>Listing 6: The LCD interrupt function</figcaption>
        <p>
          XXX
        </p>

      <h4>The tile method</h4>
        <figure>
          <video autoplay loop muted preload="auto">
            <source src="../video/parallax/tile.mp4" type="video/mp4">
            Your browser does not support the video tag.
          </video>
          <figcaption>Figure XXX: Parallax scrolling using the tile method</figcaption>
        <p>
        </p>

      <h4>Conclusion</h4>
        <!--If you want to know everything there is to know about Game Boy programming, please check out my book on the subject, <a href="https://mdagois.gumroad.com/l/CODQn" target="_blank">Game Boy Coding Adventure</a>.-->

      <!--
        Content
          Introduction
            All tested on real hardware
            Works in Game Boy Color
            Note on ghosting
                Rule of thumb to design tiles that scroll well (refer to games)
            RGBDS toolchain
          Using interrupts
            hblank
            line compare
            Using sprites for overlap
            Using one single halt or several halts
            rSCX latched at the start of the line
            Split from 2 to n layers
            Benefit: supported in hardware (light weight)
            Drawback: layers cannot overlap unless using sprites, but hit sprite limits + only 2 colors (bg sees through)
          Using tiles
            Explanation
            Benefit: layers can overlap, can work vertically, works for top down views (zelda-like or shmups)
            Drawback: uses more rom space, more work in the vblank, must respect tile boundaries
            CGB: can use DMA
          Conclusion
            Mix both techniques
            Faster data transfers on the DMG using pop slide
            No need for interrupt in an intro screen
            Read the book
            Rift effect for shmups
            More techniques: window, sprites
          Art attribution
      -->

    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
  </body>
</html>

